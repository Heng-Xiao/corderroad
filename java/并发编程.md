# 并发编程
## 一、 基础知识
### 1. 为什么要使用并发编程
+  **提升多核CPU的利用率**：一般来说一台主机上的会有多个CPU核心，我们可以创建多个线程，理论上讲操作系统可以将多个线程分配给不同的CPU去执行，每个CPU执行一个线程，这样就提高了 CPU的使用效率，如果使用单线程就只能有一个CPU核心被使用。

+ 比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。

+ 简单来说就是：

    + **充分利用多核CPU的计算能力**

    + **方便进行业务拆分，提升应用性能**

### **2. 多线程应用场景**

例如: 迅雷多线程下载、数据库连接池、分批发送短信等。

### **3. 并发编程有什么缺点**

并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、线程安全、死锁等问题。

### **4. 并发编程三个必要因素是什么？**

+ 原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。

+ 可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）

+ 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）

### **5. Java 程序中怎么保证多线程的运行安全？**

+ 出现线程安全问题的原因一般都是三个原因：
    + 线程切换带来的**原子性**问题 
      
      解决办法：使用多线程之间同步synchronized或使用锁(lock)。
    + 缓存导致的**可见性**问题 
      
      解决办法：synchronized、volatile、LOCK，可以解决可见性问题
    + 编译优化带来的**有序性**问题 
      
      解决办法：Happens-Before 规则可以解决有序性问题

### **6. 并行和并发有什么区别？**

+ 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。

+ 并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。

+ 串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。

> 做一个形象的比喻
>
> <strong>并发 =</strong> 俩个人用一台电脑。
>
> <strong>并行 =</strong> 俩个人分配了俩台电脑。
>
> <strong>串行 =</strong> 俩个人排队使用一台电脑。

### **7. 什么是多线程**

多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。

### **8. 多线程的好处**

可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

### **9. 多线程的劣势：**

+ 线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；

+ 多线程需要协调和管理，所以需要 CPU 时间跟踪线程；

+ 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。

### **10. 线程和进程区别**

什么是线程和进程?

+ 进程 : 一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程

+ 线程 : 进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。

`一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。`

+ 进程与线程的区别

    1. **根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

    2. **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

    3. **包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

    4. **内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的

    5. **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。

    6. **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

### **11. 什么是上下文切换?**

+ 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

+ 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

+ 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

+ Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

### **12. 守护线程和用户线程有什么区别呢？**

+ **用户 (User) 线程**：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程

+ **守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作

### **13. 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？**

windows上面用任务管理器看，linux下可以用 top 这个工具看。

1.找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p (shift+m是找出消耗内存最高)查找出cpu利用最厉害的pid号

2.根据上面第一步拿到的pid号，`top -H -p pid` 。然后按下`shift+p`，查找出cpu利用率最厉害的线程号，比如`top -H -p 1328`

3.将获取到的线程号转换成16进制，去百度转换一下就行使用jstack工具将进程信息打印输出，`jstack pid号 > /tmp/t.dat`，比如`jstack 31365 >/tmp/t.dat` 编辑/tmp/t.dat文件，查找线程号对应的信息

`或者直接使用JDK自带的工具查看“jconsole” 、“visualVm”，这都是JDK自带的，可以直接在JDK的bin目录下找到直接使用`

### **14. 什么是线程死锁**

死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的 一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
![image.png](/java/bfbc1.png)


### **15. 形成死锁的四个必要条件是什么**

+ 互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等待，直至占有资源的进程用毕释放。

+ 占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

+ 不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过 来。

+ 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在等B，B在等C，C在等A）

### **16. 如何避免线程死锁**
1. 避免一个线程同时获得多个锁
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3. 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制

### **17. 创建线程的四种方式**
+ 继承 Thread 类；
```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " run()方法正在执行...");
    }
}
```
+ 实现 Runnable 接口；
```java
public class MyRunnable implements Runnable
{
    @Override
    public void run()
    {
        System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
    }
}
```
+ 实现 Callable 接口；
```java
public class MyCallable implements Callable < Integer >
{
    @Override
    public Integer call()
    {
        System.out.println(Thread.currentThread().getName() + " call()方法执行中...");
        return 1;
    }
}
```
+ 使用匿名内部类方式
```java
public class CreateRunnable
{
    public static void main(String[] args)
    {
        //创建多线程创建开始
        Thread thread = new Thread(new Runnable()
        {
            public void run()
            {
                for(int i = 0; i < 10; i++)
                {
                    System.out.println("i:" + i);
                }
            }
        });
        thread.start();
    }
}
```



### **18. 说一下 runnable 和 callable 有什么区别**

**相同点：**

+ 都是接口
+ 都可以编写多线程程序
+ 都采用Thread.start()启动线程

**主要区别：**

+ Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
+ Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出 异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。

### **19. 线程的 run()和 start()有什么区别？**

+ 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。

+ start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start()只能调用一次。

+ start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。 

+ run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

### **20. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？**

这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！

+ new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片 后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行

+ run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结：调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。

### **21. 什么是 Callable 和 Future?**

+ Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。

+ Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。

### **22. 什么是 FutureTask**

FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。

### **23. 线程的状态**
![image.png](/java/bfbc2.png)
+ 新建(new)：新创建了一个线程对象。

+ 就绪（可运行状态）(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。

+ 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。
**注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；**

+ 阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。

    + 阻塞的情况分三种：

    + (一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；

    + (二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；

    + (三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。

+ 死亡(dead)(结束)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束 生命周期。死亡的线程不可再次复生。

### **24. Java 中用到的线程调度算法是什么？**

计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。 （**Java是由JVM中的线程计数器来实现线程调度**）

+ 有两种调度模型：**分时调度模型**和**抢占式调度模型**。

    + **分时调度模型**是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。

    + Java虚拟机采用**抢占式调度模型**，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。

### **25. 线程的调度策略**

线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：

（1）线程体中调用了 yield 方法让出了对 cpu 的占用权利

（2）线程体中调用了 sleep 方法使线程进入睡眠状态

（3）线程由于 IO 操作受到阻塞

（4）另外一个更高优先级线程出现

（5）在支持时间片的系统中，该线程的时间片用完


### **26. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？**

+ 线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。

+ 时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。

+ 线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

### **27. 请说出与线程同步以及线程调度相关的方法。**

（1） **wait()**：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；

（2） **sleep()**：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 **InterruptedException** 异常；

（3） **notify()**：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；

（4） **notityAll()**：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

### **28. sleep() 和 wait() 有什么区别？**

两者都可以暂停线程的执行


+ 类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。 

+ 是否释放锁：sleep() 不释放锁；wait() 释放锁。

+ 用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。

+ 用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。


### **29. 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？**

+ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没 有满足结束条件的情况下退出。

+ wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满 足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的

代码：
```java
synchronized(monitor)
{
  // 判断条件谓词是否得到满足
  while(!locked)
  {
    // 等待唤醒
    monitor.wait();
  }
  // 处理其他的业务逻辑
}
```


### **30. 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？**

因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。

有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线 程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。


### **31. 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？**

当一个线程需要调用对象的 wait() 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。


### **32. Thread 类中的 yield 方法有什么作用？**

+ 使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。
+ 当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。

### **33. 为什么 Thread 类的 sleep()和 yield ()方法是静态的？**

Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

### **34. 线程的 sleep()方法和 yield()方法有什么区别？**

（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；

（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；

（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

### **35. 如何停止一个正在运行的线程？**

在java中有以下3种方法可以终止正在运行的线程：

+ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。

+ 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。

+ 使用interrupt方法中断线程。

### **36. Java 中 interrupted 和 isInterrupted 方法的区别？**

+ interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。

`注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。`

+ interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。

+ isInterrupted：是可以返回当前中断信号是true还是false，与interrupt最大的差别

### **37. 什么是阻塞式方法？**

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

### **38. Java 中你怎样唤醒一个阻塞的线程？**

+ 首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；

+ 其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。

### **39. notify() 和 notifyAll() 有什么区别？**

+ 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。

+ notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。

+ notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。

### **40. 如何在两个线程间共享数据？**

在两个线程间共享变量即可实现共享。

`一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。`

### **41. Java 如何实现多线程之间的通讯和协作？**

+ 可以通过中断 和 共享变量的方式实现线程间的通讯和协作

`比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。`

+ Java中线程通信协作的最常见方式：

  + syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()

  + ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()

+ 线程间直接的数据交换：

  + 通过管道进行线程间通信：字节流、字符流

### **42. 同步方法和同步块，哪个是更好的选择？**

+ 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。

+ 同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

+ 同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。

`请知道一条原则：同步的范围越小越好。`



### **43. 什么是线程同步和线程互斥，有哪几种实现方式？**

+ 当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。

+ 在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。

+ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

+ 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

+ 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。

+ 实现线程同步的方法

  1. **同步代码方法**：sychronized 关键字修饰的方法

  2. **同步代码块**：sychronized 关键字修饰的代码块

  3. **使用特殊变量域volatile实现线程同步**：volatile关键字为域变量的访问提供了一种免锁机制

  4. **使用重入锁实现线程同步**：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义

### **44. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？**

+ 在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

+ 一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次 只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码

+ 另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案

### **45. 如果你提交任务时，线程池队列已满，这时会发生什么**

有俩种可能：

（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务

（2）如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是 AbortPolicy

### **46. 什么叫线程安全？servlet 是线程安全吗?**

+ 线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

+ Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。

+ Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。

+ SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。

+ Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。

### **47. 在 Java 程序中怎么保证多线程的运行安全？**

+ 方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger

+ 方法二：使用自动锁 synchronized。

+ 方法三：使用手动锁 Lock。

+ 手动锁 Java 示例代码如下：
```java
Lock lock = new ReentrantLock();
lock.lock();
try
{
    System.out.println("获得锁");
}
    catch(Exception e)
{
// TODO: handle exception
}
finally
{
    System.out.println("释放锁");
    lock.unlock();
}
```


### **48. 你对线程优先级的理解是什么？**

+ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。

+ Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。

+ 当然，如果你真的想设置优先级可以通过setPriority()方法设置，但是设置了不一定会该变，这个是不准确的

### **49. 线程类的构造方法、静态块是被哪个线程调用的**

+ 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。

+ 如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：

（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的

（2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的

### **50. Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？**

+ Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。

+ 在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。

+ 在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。

### **51. 一个线程运行时发生异常会怎样？**

如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。

### **52. Java 线程数过多会造成什么异常？**

+ 线程的生命周期开销非常高

+ **消耗过多的 CPU**: 资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占 用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。

+ **降低稳定性JVM** : 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。

### **53. 多线程的常用方法**

**方法名**| **描述**
:----:|:----:
sleep() | 强迫一个线程睡眠Ｎ毫秒
isAlive() | 判断一个线程是否存活。
join() | 等待线程终止。
activeCount() | 程序中活跃的线程数
enumerate() | 枚举程序中的线程。
currentThread() | 得到当前线程。
isDaemon() | 一个线程是否为守护线程。
setDaemon() | 设置一个线程为守护线程。
setName() | 为线程设置一个名称。
wait() | 强迫一个线程等待。
notify() | 通知一个线程继续运行。
setPriority() | 设置一个线程的优先级。

## **二、 并发理论**

### **1. Java中垃圾回收有什么目的？什么时候进行垃圾回收？**

+ 垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。

+ 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。

### **2. 线程之间如何通信及线程之间如何同步**

+ 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。

+ Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

### **3. Java内存模型**

共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

![image.png](/java/bfbc3.png)

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

  1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。

  2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

**下面通过示意图来说明线程之间的通信**

![image.png](/java/bfbc4.png)

**总结**：什么是Java内存模型：java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。

### **4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？**

不会，在下一个垃圾回调周期中，这个对象将是被可回收的。也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。

### **5. ﬁnalize()方法什么时候被调用？析构函数(ﬁnalization)的目的是什么？**

1. 垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；finalize是Object类的一个方法，该方法在Object类中的声明protected void ﬁnalize() throws Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。

`注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间`

2. GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。


3. Finalizetion主要用来释放被对象占用的资源（不是指内存，而是指其他资源，比如文件(File Handle)、端口(ports)、数据库连接(DB Connection)等）。然而，它不能真正有效地工作。

### **6. 什么是重排序**

+ 程序执行的顺序按照代码的先后顺序执行。

+ 一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，进行重新排序（重排序）， 它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
```java
int a = 5; //语句1

int r = 3;//语句2

a = a + 2;//语句3

r = a*a;//语句4
```
+ 则因为重排序，他还可能执行顺序为（这里标注的是语句的执行顺序） 2-1-3-4，1-3-2-4 但绝不可能 2-1-4-3，因为这打破了依赖关系。

+ 显然重排序对单线程运行是不会有任何问题，但是多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。

### **7. 重排序实际执行的指令步骤**

![image.png](/java/bfbc5.png)

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2. 指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不

存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在

乱序执行。

**这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。**

### **8. 重排序遵守的规则**

**as-if-serial**：

1. 不管怎么排序，结果不能改变

2. 不存在数据依赖的可以被编译器和处理器重排序

3. 一个操作依赖两个操作，这两个操作如果不存在依赖可以重排序

4. 单线程根据此规则不会有问题，但是重排序后多线程会有问题

### **9. as-if-serial规则和happens-before规则的区别**

as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多

线程程序的执行结果不被改变。

as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行

的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多

线程程序是按happens-before指定的顺序来执行的。

as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽

可能地提高程序执行的并行度。

### **10. 并发关键字 synchronized ？**

在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制

synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。

另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）

是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上

的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时

需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这

也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面

对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的

实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来

减少锁操作的开销。

### **11. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗**

**synchronized关键字最主要的三种使用方式：**

修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个

实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一

份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个

实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态

synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实

例对象锁。

修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class

类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String

a) 因为JVM中，字符串常量池具有缓存功能！

### **12. 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”**

**双重校验锁实现对象单例（线程安全）**


**说明：**

双锁机制的出现是为了解决前面同步问题和性能问题，看下面的代码，简单分析下确实是解决了多

线程并行进来不会出现重复new对象，而且也实现了懒加载

public class Singleton {

private volatile static Singleton uniqueInstance;

private Singleton() {}

public static Singleton getUniqueInstance() {

//先判断对象是否已经实例过，没有实例化过才进入加锁代码

if (uniqueInstance == null) {

//类对象加锁

synchronized (Singleton.class) {

if (uniqueInstance == null) {

uniqueInstance = new Singleton();

}

}

}

return uniqueInstance;

}

}

另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。

uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton();

这段代码其实是分为三步执行：

1. 为 uniqueInstance 分配内存空间

2. 初始化 uniqueInstance

3. 将 uniqueInstance 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，

但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用

getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时

uniqueInstance 还未被初始化。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

### **13. 说一下 synchronized 底层实现原理？**

Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，

每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就

会处于锁定状态并且尝试获取monitor的所有权 ，过程：

1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为

monitor的所有者。

2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.

3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再

重新尝试获取monitor的所有权。

synchronized是可以通过 反汇编指令 javap命令，查看相应的字节码文件。



### **14. synchronized可重入的原理**

重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线

程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0

时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。

### **15. 什么是自旋**

很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁

可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然

synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized

的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更

好的策略。

忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了

CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓

存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避

免重建缓存和减少等待重建的时间就可以使用它了。

### **16. 多线程中 synchronized 锁升级的原理是什么？**

synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候

threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断

threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为

轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的

对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方

式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访

问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比

如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇

到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标

准的轻量级锁。

轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁

争用的时候，轻量级锁就会升级为重量级锁；

重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻

塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。

### **17. 线程 B 怎么知道线程 A 修改了变量**

（1）volatile 修饰变量

（2）synchronized 修饰修改变量的方法

（3）wait/notify

（4）while 轮询



### **18. 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入**

**此对象的 synchronized 方法 B？**

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的

synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取

走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### **19. synchronized、volatile、CAS 比较**

（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。

（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。

（3）CAS 是基于冲突检测的乐观锁（非阻塞）

### **20. synchronized 和 Lock 有什么区别？**

首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；

synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。

synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；

而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。

通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

### **21. synchronized 和 ReentrantLock 区别是什么？**

synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质

区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继

承、可以有方法、可以有各种各样的类变量

synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在

Java 6 中对 synchronized 进行了非常多的改进。

相同点：两者都是可重入锁

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对

象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不

可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器

下降为0时才能释放锁。

主要区别如下：

ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；

ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；

ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。

二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，

synchronized 操作的应该是对象头中 mark word

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

普通同步方法，锁是当前实例对象

静态同步方法，锁是当前类的class对象

同步方法块，锁是括号里面的对象

### **22. volatile 关键字的作用**



对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-

before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰

时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新

值。

从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见

java.util.concurrent.atomic 包下的类，比如 AtomicInteger。

volatile 常用于多线程环境下的单次操作(单次读或者单次写)。

### **23. Java 中能创建 volatile 数组吗？**

能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思

是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元

素，volatile 标示符就不能起到之前的保护作用了。

### **24. volatile 变量和 atomic 变量有什么不同？**

volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。

例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。

而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会

原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

### **25. volatile 能使得一个非原子操作变成原子操作吗？**

关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同

一个实例变量需要加锁进行同步。

虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子

性。

**所以从Oracle Java Spec里面可以看到：**

对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时

候，可以分成两步，每次对32位操作。

如果使用volatile修饰long和double，那么其读写都是原子操作

对于64位的引用地址的读写，都是原子操作

在实现JVM时，可以自由选择是否把读写long和double作为原子操作

推荐JVM实现为原子操作

### **26. synchronized 和 volatile 的区别是什么？**

synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。

volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的

可见性；禁止指令重排序。

**区别**

volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。

volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改

可见性和原子性。

volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是

volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键

字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻

量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场

景还是更多一些。

### **27. ﬁnal不可变对象，它对写并发应用有什么帮助？**

不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就

不能改变，反之即为可变对象(Mutable Objects)。

不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如

String、基本类型的包装类、BigInteger 和 BigDecimal 等。

只有满足如下状态，一个对象才是不可变的；

它的状态不能在创建后再被修改；

所有域都是 ﬁnal 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。

不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。

### **28. Lock 接口和synchronized 对比同步它有什么优势？**

Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完

全不同的性质，并且可以支持多个相关类的条件对象。

它的优势有：

（1）可以使锁更公平

（2）可以使线程在等待锁的时候响应中断

（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间

（4）可以在不同的范围，以不同的顺序获取和释放锁

整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定

时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操

作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当

然，在大部分情况下，非公平锁是高效的选择。

### **29. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？**

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候

都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多

这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的

同步原语 synchronized 关键字的实现也是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是

在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适

用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write\_condition 机制，其实

都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观

锁的一种实现方式 CAS 实现的。

### **30. 什么是 CAS**

CAS 是 compare and swap 的缩写，即我们所说的比较交换。


cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁

住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态

度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很

大的提高。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的

值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果

在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才

有可能机会执行。

java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的

(AtomicInteger,AtomicBoolean,AtomicLong)

### **31. CAS 的会产生什么问题？**

1、ABA 问题：

比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进

行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存

中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从

Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。

2、循环时间长开销大：

对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，

效率低于 synchronized。

3、只能保证一个共享变量的原子操作：

当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量

操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。

### **32. 什么是原子类**

java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解除锁的线程安全编程

原子变量类相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-改-写操作。

比如：AtomicInteger 表示一个int类型的值，并提供了 get 和 set 方法，这些 Volatile 类型的int

变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndSet 方法（如果该

方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、

递增和递减等方法。AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况

下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。

简单来说就是原子类来实现CAS无锁模式的算法

### **33. 原子类的常用类**

AtomicBoolean

AtomicInteger

AtomicLong

AtomicReference

### **34. 说一下 Atomic的原理？**



Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引

用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线

程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。

### **35. 死锁与活锁的区别，死锁与饥饿的区别？**

死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的

现象，若无外力作用，它们都将无法推进下去。

活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失

败。

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的

实体表现为等待；活锁有可能自行解开，死锁则不能。

饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。

Java 中导致饥饿的原因：

1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。

2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该

同步块进行访问。

3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其

他线程总是被持续地获得唤醒。