# 面向对象

## 一、 面向对象概述
### 1. 面向对象和面向过程的区别
面向对象编程（OOP）和面向过程编程（POP）是两种主要的编程范式，它们在问题分解、功能划分和代码结构等方面存在显著差异。具体分析如下：

1. **问题分解**：面向过程编程强调的是任务的执行顺序和步骤，它将问题分解为一系列的过程或函数，每个过程负责完成特定的任务。而面向对象编程则是将问题分解为一系列的对象，每个对象包含数据和操作数据的方法，对象之间通过消息传递来协作完成任务。
2. **功能划分**：在面向过程中，功能被划分为独立的函数，每个函数是一个独立的逻辑单元。在面向对象中，功能被封装在对象中，对象的状态和行为被封装在一起，形成了一个整体。
3. **代码结构**：面向过程的代码结构通常由一系列的函数组成，函数之间通过参数和返回值进行交互。面向对象的代码结构则由类和对象组成，类定义了对象的模板，对象是类的实例。
4. **设计思路**：面向过程的设计思路是以事件为中心，关注点在于如何通过一系列的步骤来解决问题。面向对象的设计思路是以“对象”为中心，关注点在于如何模拟现实世界中的实体以及它们之间的相互作用。
5. **抽象层次**：面向过程倾向于低层次的抽象，关注的是具体的操作和算法。面向对象则倾向于高层次的抽象，关注的是对象的属性和行为，以及对象之间的交互。
6. **复用和维护**：面向过程的代码复用性相对较低，因为功能被分散在不同的函数中。面向对象的代码复用性较高，因为可以通过继承和多态来重用已有的类和对象。
7. **适用场景**：面向过程适用于问题明确、流程清晰的情况，如简单的脚本或工具。面向对象适用于问题复杂、需求变化频繁的情况，如大型软件系统或应用开发。

总的来说，面向对象和面向过程各有优势和局限，它们各自适用于不同的场景和问题。在实际开发中，这两种范式往往会结合使用，以达到最佳的开发效果。
## 二、 面向对象三大特性
### 1.  面向对象的特征有哪些方面
面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件和编写代码。以下是面向对象编程的几个关键特征：

1. **封装**：封装是指将数据（属性）和操作数据的函数（方法）绑定在一起，形成一个整体，即对象。这样可以隐藏对象的内部细节，只暴露出有限的接口与外界交互，增强了代码的安全性和模块化。
2. **继承**：继承是一种能够创建新类的方式，新创建的类被称为子类或派生类，被继承的类称为父类或基类。子类继承父类的属性和方法，同时也可以添加新的属性和方法或者重写父类的方法，这有助于减少代码重复，提高代码的复用性。
3. **多态**：多态是指允许一个接口使用多种实际类型的能力。简单来说，多态让不同的对象可以用相同的接口进行操作，具体调用哪个对象的方法则是在运行时动态决定的。多态性提高了程序的灵活性和可扩展性。
4. **抽象**：抽象是指简化复杂系统的方法，通过忽略一些细节来减少系统的复杂性。在面向对象编程中，可以通过抽象类或接口来定义通用的属性和方法，然后由具体的类来实现这些抽象类或接口，从而实现代码的通用性和可维护性。

这些特征共同构成了面向对象编程的基础，它们使得程序员能够更好地组织和管理复杂的代码，提高了软件的可维护性、可扩展性和可重用性。
### 2. 什么是多态机制？Java语言是如何实现多态的？
**多态机制允许不同的对象对同一消息做出响应**。
多态是指允许一个接口使用多种实际类型的能力，是方法的多态，而不是属性的多态。

在面向对象编程中，多态性是一个非常重要的概念，它允许不同的对象对同一消息做出响应。这意味着即使多个对象可能是不同类型的实例，但它们可以以统一的方式处理，只要它们共享相同的方法签名。

在Java语言中，多态的实现主要依靠以下几种机制：

1. **继承（Extends）**：子类继承父类时，可以重写（Override）父类的方法，使得同一个方法名在不同的子类中有不同的实现。这样，当通过父类引用调用该方法时，实际上执行的是子类中的版本。
2. **接口实现（Implements）**：类可以实现一个或多个接口，并且必须实现接口中定义的所有方法。这使得多个不相关的类可以对接口中定义的方法提供不同的实现。
3. **动态绑定（Dynamic Binding）**：这是Java实现多态的技术之一，指的是在运行时根据对象的实际类型来调用相应的方法。

此外，要实现多态，还需要满足以下三个条件：

1. **要有继承关系**：即子类与父类之间存在继承关系。
2. **要有方法重写**：子类需要重写父类中的方法，以提供不同的行为。
3. **父类引用指向子类对象**：这是通过将父类的引用变量指向子类的对象实例来实现的。

综上所述，多态的优势在于增加了程序的灵活性和可扩展性，同时减少了类型之间的耦合关系，使得代码更加简洁和易于维护。
### 3. 面向对象五大基本原则是什么（可选）
面向对象的五大基本原则是：

1. **单一职责原则**：一个类应该只有一个引起变化的原因。这个原则强调一个类应该只负责一项职责，如果一个类承担了过多的职责，那么这些职责中任何一个发生变化都会导致类的变化，从而增加了维护的困难和出错的风险。
2. **开放封闭原则**：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着一个实体可以在不修改其源代码的情况下被扩展，通常通过继承和多态来实现。
3. **里氏替换原则**：所有引用基类的地方必须能透明地使用其子类的对象。这个原则是说，如果每个子类对象都能替换其父类对象并且程序行为不会改变，那么该程序就是里氏替换的。
4. **迪米特法则**：一个对象应当对其他对象有尽可能少的了解。简单来说，一个对象应该只与直接的朋友交谈，不跟“陌生人”说话。
5. **接口隔离原则**：客户端不应该依赖于它不使用的接口。这个原则告诉我们，应该将大的接口拆分成多个小的接口，每个接口服务于一个子模块或业务逻辑。

这些原则共同构成了面向对象设计的基础，它们旨在提高代码的可读性、可维护性和可扩展性。在实际开发中，遵循这些原则能够帮助开发者构建出更加健壮和灵活的软件系统。
## 三、 类与接口
### 1. 抽象类和接口的对比
抽象类和接口在Java中都是用于实现多态和继承的特性，它们有一些共同点，但也有一些关键的区别。

- **共同点**：
1. 两者都不能直接实例化，需要由子类或实现类来实例化。
2. 都包含抽象方法，这些方法需要在子类或实现类中被具体实现。
3. 都可以定义普通方法，这些方法可以在抽象类中实现，也可以在接口中默认实现（自Java 8起）。

- **不同点**：
1. **继承与实现**：一个类可以实现多个接口，但只能继承一个抽象类。这意味着接口可以提供多重继承的能力，而抽象类则不行。
2. **成员变量**：接口中的变量默认是public static final的，不能有其他类型的变量。而抽象类可以有各种类型的成员变量，包括非静态和非最终的。
3. **构造方法**：抽象类可以有构造方法，而接口不能有构造方法。
4. **访问修饰符**：抽象类中的方法可以具有不同的访问修饰符，包括public、protected等，而接口中的方法默认都是public的。
5. **静态方法**：在Java 8之前，接口中不能包含静态方法，但从Java 8开始，接口中可以包含默认方法和静态方法。抽象类则一直可以包含静态方法。

总的来说，抽象类更适合那些密切相关的类，它们具有相同的基本行为，但每个子类可能会有自己独特的实现方式。而接口更适合为不相关的类提供统一的行动规范，确保它们至少提供某些特定的行为。
### 2. 普通类和抽象类有哪些区别？
普通类和抽象类在Java中都是类的两种形态，它们在能否实例化、方法实现和用途上存在明显的区别。

1. **能否实例化**：
- 普通类可以被实例化，即可以使用`new`关键字来创建对象。
- 抽象类不能被直接实例化，也就是说，不能使用`new`关键字来创建抽象类的实例。

2. **方法实现**：
- 普通类中的方法必须有具体的实现，否则编译器会报错。
- 抽象类可以包含没有具体实现的抽象方法，这些方法需要在子类中被覆盖并提供实现。

3. **用途**：
- 普通类通常用于定义具体的对象，包含属性和行为。
- 抽象类主要用于作为基类，为子类提供一个公共的类型和通用的行为，特别是当这些行为在抽象类中无法具体实现时。

总的来说，普通类和抽象类在Java编程中扮演着不同的角色。普通类用于创建具体的对象实例，而抽象类则作为一种模板，用于定义子类必须遵循的规范。在实际开发中，根据具体的需求来选择使用普通类还是抽象类是非常重要的。
### 3. 抽象类能使用 final 修饰吗？
**不，抽象类不能使用final修饰符**。

在Java中，`final`和`abstract`是两个互相矛盾的关键字。`final`关键字用于表示一个类不能被继承，也就是说，如果一个类被声明为`final`，那么它就不能有子类。而`abstract`关键字则用于表示一个类包含抽象方法，这些方法没有具体的实现，需要由子类来提供具体的实现。因此，一个类不能同时被声明为`final`和`abstract`，因为这样的类既不能被继承（由于`final`），又需要被继承（由于`abstract`），这在逻辑上是自相矛盾的。

此外，`final`还可以用来修饰方法和变量，表示这些方法和变量不能被修改。当`final`修饰一个方法时，该方法不能被子类重写；当`final`修饰一个变量时，该变量的值在初始化后不能再被改变。

总的来说，`final`和`abstract`各自有不同的用途和含义，它们不能一起使用。在实际编程中，需要根据具体的需求来选择合适的关键字来声明类、方法和变量。
### 4. 创建一个对象用什么关键字？对象实例与对象引用有何不同？
在Java中，创建一个对象通常使用**new关键字**。对象实例与对象引用的主要区别在于**内存位置和生命周期**等。

在Java编程中，创建对象的过程通常涉及使用`new`关键字。通过这个关键字，可以在堆内存中为对象分配空间，并调用相应的构造函数来初始化这个对象。例如，`MyClass obj = new MyClass();`就是创建了`MyClass`的一个实例，并将其引用赋值给变量`obj`。除了使用`new`关键字这种常见的方法之外，还可以通过反射、克隆、反序列化等方式来创建对象。

- 对象实例指的是通过`new`关键字创建的具体的实体，它存在于Java的堆内存中。
- 对象引用则是指向对象实例的变量名，它存储在栈内存里，并用于访问对象实例的属性和方法。

简单来说，对象引用相当于一个指针，指向实际的对象实例。一个对象引用可以指向一个或多个对象实例，而一个对象实例也可以被多个对象引用所指向。

综上所述，当我们谈论创建Java对象时，我们通常是在使用`new`关键字来实例化一个类的对象。而理解对象实例与对象引用之间的区别对于掌握Java的内存管理和代码优化是非常关键的。
## 四、 变量与方法
### 1. 成员变量与局部变量的区别有哪些
成员变量和局部变量在Java中都是用于存储数据的变量，但它们在生命周期、作用范围以及初始化方面存在显著的区别。具体来说：

1. **生命周期**：
- 成员变量的生命周期与对象相同，即随着对象的创建而分配内存，随着对象的销毁而释放内存。
- 局部变量的生命周期则仅限于它所在的方法或代码块，当方法执行完毕或代码块执行完毕后，局部变量就会从栈内存中消失。
2. **作用范围**：
- 成员变量的作用范围是类级别的，也就是说，同一个类的所有实例对象都可以访问到这个成员变量（当然，这取决于成员变量的访问修饰符）。
- 局部变量的作用范围则局限于它被声明的方法或代码块内部，只能在该方法或代码块内部被访问。
3. **初始化**：
- 成员变量可以有默认值，如数值类型默认为0，布尔类型默认为false，引用类型默认为null。
- 局部变量在使用前必须显式地赋值，否则会出现编译错误。

总的来说，理解这些区别对于编写高质量的Java代码至关重要，它有助于我们更好地管理内存资源，避免潜在的错误，并提高代码的可读性和可维护性。
### 2. 在Java中定义一个不做事且没有参数的构造方法的作用
在Java中，定义一个不做事且没有参数的构造方法的作用是提供一个默认的构造方法。

当一个类没有任何构造方法时，编译器会自动为该类生成一个默认的无参构造方法。这个默认的构造方法是一个空方法，它不会执行任何操作。

然而，如果程序员显式地为类定义了一个或多个构造方法，那么编译器就不会再自动生成默认的无参构造方法了。在这种情况下，如果没有提供无参构造方法，可能会导致一些问题。例如，当我们使用反射来创建类的实例时，如果没有无参构造方法，就会抛出异常。

因此，为了确保类的可实例化性和可扩展性，通常建议为类提供一个无参构造方法。这样，即使程序员没有显式地定义其他构造方法，也可以保证类可以被正确地实例化和使用。
### 3.  在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？
帮助子类做初始化工作。
### 4. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
### 5. 构造方法有哪些特性？
- 名字与类名相同；
- 没有返回值，但不能用void声明构造函数；
- 生成类的对象时自动执行，无需调用。
### 6. 静态变量和实例变量区别
- 静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。
- 实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。
### 8. 静态变量与普通变量区别
- static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。
- 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。
### 9. 静态方法和实例方法有何不同？
静态方法和实例方法的区别主要体现在两个方面：
- 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制
### 10. 在一个静态方法内调用一个非静态成员为什么是非法的？
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### 11. 什么是方法的返回值？返回值的作用是什么？
方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！
## 五、 内部类
### 1. 什么是内部类？
在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。
### 2. 内部类的分类有哪些
内部类在Java中是一种特殊类型的类，它们定义在另一个类的内部。具体来说，内部类可以分为以下几类：

1. **成员内部类**：定义在类内部，成员位置上的非静态类，就是成员内部类。
```java
public class Outer
{
    private static int radius = 1;
    private int count = 2;
    class Inner
    {
        public void visit()
        {
            System.out.println("visit outer static  variable:" + radius);
            System.out.println("visit outer   variable:" + count);
        }
    }
}
```
成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：
```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
inner.visit();
```
2. **静态内部类**：定义在类内部的静态类，就是静态内部类。
```java
public class Outer
{
    private static int radius = 1;
}
static class StaticInner
{
    public void visit()
    {
        System.out.println("visit outer static  variable:" + radius);
    }
}
```
静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：
```java
Outer.StaticInner inner = new Outer.StaticInner();
inner.visit();
```
3. **局部内部类**：定义在方法中的内部类，就是局部内部类。
```java
  public class Outer
{
    private int out_a = 1;
    private static int STATIC_b = 2;
    public void testFunctionClass()
    {
        int inner_c = 3;
        class Inner
        {
            private void fun()
            {
                System.out.println(out_a);
                System.out.println(STATIC_b);
                System.out.println(inner_c);
            }
        }
        Inner inner = new Inner();
        inner.fun();
    }
    public static void testStaticFunctionClass()
    {
        int d = 3;
        class Inner
        {
            private void fun()
            {
                // System.out.println(out_a); 编译错误，定义在静态方法中的局部
                类不可以访问外部类的实例变量
                System.out.println(STATIC_b);
                System.out.println(d);
            }
        }
        Inner inner = new Inner();
        inner.fun();
    }
}
```
定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：
```java
public static void testStaticFunctionClass()
        {
class Inner
{}
    Inner inner = new Inner();
}
```
4. **匿名内部类**：匿名内部类就是没有名字的内部类，日常开发中使用的比较多。
```java
public class Outer
{
    private void test(final int i)
    {
        new Service()
        {
            public void method()
            {
                for(int j = 0; j < i; j++)
                {
                    System.out.println("匿名内部类");
                }
            }
        }.method();
    }
}
//匿名内部类必须继承或实现一个已有的接口
interface Service
{
    void method();
}
```
除了没有名字，匿名内部类还有以下特点：
 + 匿名内部类必须继承一个抽象类或者实现一个接口。
 + 匿名内部类不能定义任何静态成员和静态方法。
 + 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
 + 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

匿名内部类创建方式：
```java
new 类/接口{
//匿名内部类实现部分
}
```
### 3. 内部类的优点
我们为什么要使用内部类呢？因为它有以下优点：
+ 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
+ 内部类不为同一包的其他类所见，具有很好的封装性；
+ 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
+ 匿名内部类可以很方便的定义回调。
### 4. 内部类有哪些应用场景
1. 一些多算法场合
2. 解决一些非面向对象的语句块。
3. 适当使用内部类，使得代码更加灵活和富有扩展性。
4. 当某个类除了它的外部类，不再被其他的类使用时。
### 5. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？
局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：
```java
public class Outer
{
    void outMethod()
    {
        final int a = 10;
        class Inner
        {
            void innerMethod()
            {
                System.out.println(a);
            }
        }
    }
}
```
以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。
### 6. 内部类相关，看程序说出运行结果
```java
 public class Outer
{
    private int age = 12;
    class Inner
    {
        private int age = 13;
        public void print()
        {
            int age = 14;
            System.out.println("局部变量：" + age);
            System.out.println("内部类变量：" + this.age);
            System.out.println("外部类变量：" + Outer.this.age);
        }
    }
    public static void main(String[] args)
    {
        Outer.Inner in = new Outer().new Inner(); in .print();
    }
}
```
运行结果：
```java
局部变量：14
内部类变量：13
外部类变量：12
```
## 六、 重写与重载
### 1. 构造器（constructor）是否可被重写（override）
构造器不能被继承，因此不能被重写，但可以被重载。
### 2.  重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
方法的重载和重写都是实现多态的方式，区别在于前者实现的是**编译时的多态性**，而后者实现的是**运行时的多态性**。
+ **重载**：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
+ **重写**：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。
## 七、 对象相等判断
### 1. == 和 equals 的区别是什么
+ **==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数
据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)
+ **equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
    + 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
    + 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。
    + 举个例子：
```java
public class test1
{
    public static void main(String[] args)
    {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if(aa == bb) // true
            System.out.println("aa==bb");
        if(a == b) // false，非同一对象
            System.out.println("a==b");
    }
}
if(a.equals(b)) // true
    System.out.println("aEQb");
if(42 == 42.0)
{ // true
    System.out.println("true");
}
```
+ 说明：
    + String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。
    + 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

### 2. hashCode 与 equals (重要)
+ HashSet如何检查重复
+ 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？
+ hashCode和equals方法的关系
+ 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”

1. **hashCode()介绍**
+ hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。
+ 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

2. **为什么要有 hashCode**

`我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：`

+ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

3. **hashCode()与equals()的相关规定**

+ 如果两个对象相等，则hashcode一定也是相同的
+ 两个对象相等，对两个对象分别调用equals方法都返回true
+ 两个对象有相同的hashcode值，它们也不一定是相等的

`因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖`

`hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）`

### 3. 对象的相等与指向他们的引用相等，两者有什么不同？
对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。
## 八、 值传递
### 1. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的
### 2. 为什么 Java 中只有值传递
+ 首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。
+ Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。
### 3. 值传递和引用传递有什么区别
+ 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。
+ 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。
## 九、 Java包
### 1. JDK 中常用的包有哪些
+ java.lang：这个是系统的基础类；
+ java.io：这里面是所有输入输出有关的类，比如文件操作等；
+ java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；
+ java.net：这里面是与网络有关的类；
+ java.util：这个是系统辅助类，特别是集合类；
+ java.sql：这个是数据库操作的类。
### 2. import java和javax有什么区别
刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。

**所以，实际上java和javax没有区别。这都是一个名字。**