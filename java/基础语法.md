# 基础语法
## 一、 数据类型
### 1. Java有哪些数据类型
Java语言定义了以下基本数据类型：

- **整数型（int）**：通常用于表示整数，占用4个字节的存储空间。
- **长整型（long）**：用于表示较大的整数，占用8个字节的存储空间。
- **字符型（char）**：用于表示单个字符，占用2个字节的存储空间。
- **布尔型（boolean）**：用于表示逻辑值true或false，占用1位的存储空间。
- **浮点型（float）**：用于表示单精度浮点数，占用4个字节的存储空间。
- **双精度型（double）**：用于表示双精度浮点数，占用8个字节的存储空间。
- **短整型（short）**：用于表示较小范围的整数，占用2个字节的存储空间。
- **字节型（byte）**：用于表示较小范围的整数，占用1个字节的存储空间。

此外，Java还支持通过类和接口来构造的复杂数据类型，如数组、类实例和接口实现等。
以下是一个简化的Java基本数据类型图：

| 数据类型 | 占用字节数 | 数值范围                                                      |
|--------|----------|-------------------------------------------------------------|
| byte   | 1        | -128 to 127 (-2^7 to 2^7-1)                                    |
| short  | 2        | -32,768 to 32,767 (-2^15 to 2^15-1)                            |
| int    | 4        | -2,147,483,648 to 2,147,483,647 (-2^31 to 2^31-1)             |
| long   | 8        | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (-2^63 to 2^63-1) |
| float  | 4        | Approximate range: ±3.4E-45 to ±3.4E38 with ~7 digits precision |
| double | 8        | Approximate range: ±4.9E-324 to ±1.8E308 with ~15 digits precision |
| char   | 2        | '\u0000' to '\uffff' (0 to 65,535)                           |
| boolean | -       | true or false                                                 |

### 2. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String上
**switch 语句可以作用在 byte 类型上，不能直接作用在 long 类型上，但从 Java 7 版本开始可以作用在 String 类型上**。

Java 语言中的 switch 语句用于多分支选择。关于 switch 语句能作用的数据类型，具体如下：

1. **byte类型**：由于 byte 类型能够被隐式转换为 int 类型，因此它可以作为 switch 语句的表达式。
2. **long类型**：long 类型不能隐式转换为 int 类型，因此它不能直接作为 switch 语句的表达式。如果需要使用 long 类型作为 switch 的参数，必须将其强制转换为 int 型才可以。
3. **String类型**：从 Java 7 版本开始，switch 语句支持 String 类型作为其表达式。这一特性使得 switch 语句能够更加灵活地处理字符串比较的场景。

总结来说，switch 语句在数据类型的支持上有一定的限制，但同时也提供了扩展性，尤其是对字符串的支持，这使得它在编写逻辑时更加方便和实用。
### 3. 用最有效率的方法计算 2 乘以 8
使用位运算的方法计算 2 × 8，可以看作是将数字2左移3位（因为2^3 = 8），所以：

2 × 8 = 2 << 3 = 16

最终答案是16。

### 4. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少
`Math.round()` 函数返回一个数字四舍五入后最接近的整数。

对于 `Math.round(11.5)`，11.5 四舍五入后最接近的整数是 12。

对于 `Math.round(-11.5)`，-11.5 四舍五入后最接近的整数是 -11。

因此：

Math.round(11.5) = 12

Math.round(-11.5) = -11
### 5. float f=3.4;是否正确
在 Java 编程语言中，声明和初始化一个 `float` 类型的变量时，默认的数值是带有 `f` 或 `F` 后缀的，以表示它是一个浮点数字面量。如果不带这个后缀，Java 会把它当作 `double` 类型的字面量。

因此，`float f = 3.4;` 实际上是不正确的，因为它会产生一个编译时错误。正确的做法应该是在数字后面加上 `f` 或 `F` 后缀，像这样：

```java
float f = 3.4f;
```
或者，你也可以使用类型转换来显式地将 `double` 类型的值转换为 `float` 类型：
```java
float f = (float) 3.4;
```
总结来说，不带后缀的 `3.4` 默认被视为 `double` 类型，而不是 `float` 类型。为了正确地初始化一个 `float` 类型的变量，你需要在数值后面加上 `f` 或 `F` 后缀，或者使用类型转换。
### 6. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗
* 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换
  类型才能赋值给 short 型。
* 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强
  制类型转换。

## 二、 编码
### 1. Java语言采用何种编码方案？有何特点？
Java语言采用的是Unicode编码方案。Unicode是一种国际标准字符集，它为世界上几乎所有的字符分配了一个唯一的数字编号，包括英文字母、汉字、日文、韩文等。
它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用
## 三、 注释
### 1. 什么是Java注释
Java注释是**为了提高代码的可读性和可维护性而添加的文本信息**，它们不会被编译器编译到最终的可执行程序中。

Java注释主要分为以下几种类型：

1. **行注释**：使用`//`来注释一行。例如，`// 这是一行注释`。这种注释适用于对某一行代码进行简短说明。
2. **块注释**：使用`/*`开始，`*/`结束来注释多行。例如：
   ```java
   /*
    * 这是一个多行注释的例子
    */
   ```
3. **文档注释**：也称为Javadoc注释，使用`/**`开始，`*/`结束。通常用于类、方法或字段之前，包含作者、日期、简要描述等信息，并可以被Javadoc工具用来生成HTML格式的API文档。例如：
   ```java
   /**
    * @author 你的名字
    * @description 方法的描述
    */
   public void myMethod() {...}
   ```

此外，Java还支持**注解（Annotation）**，这是一种特殊类型的注释，它可以被嵌入到字节码中，并且在运行时可以通过反射获取其内容。

总之，无论是为了解释代码逻辑，还是为了记录编程思路，注释在Java编程中都扮演着重要的角色。良好的注释习惯能够显著提升代码的可读性和维护性，对于团队合作和项目传承尤为重要。
> 注意事项：多行和文档注释都不能嵌套使用。
## 四、 访问修饰符
### 1. 访问修饰符 public、private、protected、以及不写（默认）时的区别
在Java中，访问修饰符`public`、`private`、`protected`以及默认不写修饰符时有明显的区别。

下面是Java中访问修饰符的列表，展示了各种修饰符在不同上下文中的可访问性：

| 修饰符 | 当前类 | 同包 | 子类 | 其他包 |
| ------ | ------ | ---- | ---- | ------ |
| public | 是     | 是   | 是   | 是     |
| private | 是    | 是   | 否   | 否     |
| protected | 是  | 是   | 是   | 否     |
| 默认（无修饰符） | 是  | 是   | 否   | 否     |

- **Public**: 当成员被`public`修饰时，它可以被任何其他类访问，不管这些类位于同一包内还是不同的包中。`public`提供了最广泛的访问级别。
- **Private**: 成员如果被`private`修饰，则只能被其定义所在的类访问。这种修饰符隐藏了类的实现细节，不允许子类以及任何其他类访问`private`成员，从而提供了优秀的封装性和数据安全性。
- **Protected**: `protected`修饰的成员可以被同一包内的任何其他类访问，也可以被不同包中的子类访问。这在继承的时候特别有用，因为子类通常需要访问父类的特定成员。
- **默认（无修饰符）**：如果没有指定任何访问修饰符，则使用默认访问级别，也称为包级私有访问。这意味着该成员只能被同一个包内的类访问，对于其他包中的类则是不可见的。


总的来说，通过合理地使用这些访问修饰符，可以控制类成员的可见性和访问范围，确保了程序的安全性和良好的封装性。
## 五、 运算符
### 1. &和&&的区别
在计算机编程中，&和&&都是逻辑运算符，用于进行逻辑与操作。它们的区别如下：

1. &是按位与运算符，用于对二进制数进行按位与操作。它将两个数的每一位进行逻辑与操作，如果两个对应位都为1，则结果为1，否则为0。例如，5（二进制表示为101）和3（二进制表示为011）进行按位与操作的结果为1（二进制表示为001）。

2. &&是逻辑与运算符，用于对布尔值进行逻辑与操作。它只有当两个操作数都为真（true）时，结果才为真（true），否则为假（false）。例如，true和true进行逻辑与操作的结果为true，而true和false进行逻辑与操作的结果为false。

总结：&是按位与运算符，用于对二进制数进行按位与操作；&&是逻辑与运算符，用于对布尔值进行逻辑与操作。

## 六、 关键字
### 1. Java 有没有 goto
Java语言中**没有实现goto语句**。

虽然在Java中，**goto是保留的关键字**，但它并没有具体的实现。Java的设计者认为，goto语句可能导致代码的不正确性和可读性变差，因而在Java中取消了这种语句的使用。Java程序员通常会使用其他控制流语句，如if、while、do-while、for、break和continue等来控制程序的流程。这些结构可以实现与goto类似的控制逻辑，同时保持代码的清晰性和易于维护性。例如，带标签的break和continue语句可以在一定范围内跳转，但它们必须位于循环体或条件选择体内。

总的来说，尽管在某些情况下goto语句可能看起来能够提供便利，但在现代编程实践中，通常建议避免使用goto，而是采用更加结构化的编程方法来提高代码的可读性和可维护性。

### 2.  final 有什么用？
在Java中，final关键字主要用来限制实体的修改或扩展，用于修饰类、属性和方法
- 被final修饰的类不可以**被继承**
- 被final修饰的方法不可以**被重写**
- 被final修饰的变量不可以**被改变**，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的
### 3. final finally finalize区别
在Java中，final、finally和finalize虽然听起来相似，但它们的用途和含义完全不同。具体分析如下：

- **final**：用于声明属性、方法和类，表示属性不可改变，方法不可覆盖，类不可继承。使用final关键字可以保证数据的一致性和安全性，以及确保某些代码逻辑不被更改。
- **finally**：是异常处理结构的一部分，无论是否发生异常，finally块中的代码总是会被执行。它通常用于资源的清理工作，如关闭文件、释放锁等。
- **finalize**：是Object类的一个方法，它在垃圾收集器执行时会被调用，供垃圾收集时进行资源回收。然而，finalize机制不推荐使用，并且在JDK 9开始已被标记为deprecated。

总的来说，final关键字有助于提升代码的可读性和安全性；finally块确保了关键代码的执行；而finalize方法曾经用于资源清理，但现代Java开发中已不推荐使用。

### 4. this关键字的用法
在Java中，`this`关键字用于引用当前对象。以下是`this`关键字的几种用法和示例代码：

1. **引用当前对象**：当需要从方法内部访问对象的其他成员（如属性、其他方法等）时，可以使用`this`关键字。

```java
public class Person {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void printInfo() {
        System.out.println("Name: " + this.name + ", Age: " + this.age);
    }
}
```

2. **区分成员与局部变量**：如果方法的局部变量与类的成员变量同名，可以使用`this`关键字来区分。

```java
public class Counter {
    private int count;

    public void increase() {
        int count = 1; // 局部变量count
        this.count += count; // 使用this关键字引用成员变量count
    }
}
```

3. **调用当前类的其他构造函数**：在构造函数中，可以使用`this()`调用同一类的其他构造函数。

```java
public class Person {
    private String name;
    private int age;

    public Person() {
        this("Unknown", 0); // 调用另一个构造函数
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

4. **传递当前类的实例**：可以将`this`作为参数传递给其他方法，从而让其他方法能够访问当前对象的字段和方法。

```java
public class Person {
    private String name;
    private int age;

    public void printInfo() {
        System.out.println("Name: " + this.name + ", Age: " + this.age);
    }

    public void updateInfo(Person person) {
        person.printInfo(); // 通过传递this作为参数，调用printInfo方法
    }
}
```

总的来说，`this`关键字在Java中是一个非常重要的概念，它使得对象能够引用自身，并在需要时进行自我操作或与其他对象进行交互。

### 5. super关键字的用法
在Java中，`super`关键字主要有两种用途：

1. **调用父类的构造函数**：在子类的构造函数中，可以使用`super()`来调用父类的构造函数。这通常用于初始化从父类继承的成员变量。

2. **调用父类的方法**：在子类的方法中，可以使用`super`来调用父类中被覆盖（重写）的方法。

使用`super`关键字时需要注意以下几点：
- 子类构造函数默认会调用父类的无参构造函数。如果父类没有无参构造函数，子类的构造函数必须显式地使用`super`来调用父类的一个构造函数。
- 如果子类方法覆盖了父类的方法，但仍想调用父类的方法实现，可以使用`super`来调用。
- `super`可以引用父类的静态成员，但更常见的是用类名直接引用静态成员。

以下是`super`关键字的示例代码：

```java
class Parent {
    String name;

    // 父类的构造函数
    public Parent(String name) {
        this.name = name;
    }

    // 父类的方法
    public void printName() {
        System.out.println("Parent's name is " + name);
    }
}

class Child extends Parent {
    String surname;

    // 子类的构造函数，使用super调用父类的构造函数
    public Child(String name, String surname) {
        super(name); // 调用父类的构造函数
        this.surname = surname;
    }

    // 子类覆盖了父类的方法，并使用super调用父类的方法
    @Override
    public void printName() {
        super.printName(); // 调用父类的方法
        System.out.println("Child's surname is " + surname);
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child("John", "Doe");
        child.printName(); // 输出：
                            // Parent's name is John
                            // Child's surname is Doe
    }
}
```

在这个例子中，`Child`类通过`super`关键字调用了`Parent`类的构造函数和方法。
### 6.  this与super的区别
`this`和`super`是Java中两个非常重要的关键字，它们在很多方面都起着关键作用。具体来说：

- **指代对象不同**：`this`关键字代表当前对象，即调用者对象，而`super`关键字代表父类空间的引用，用于访问父类的成员变量和方法。
- **使用前提不同**：`super`关键字必须要有继承关系才能使用，因为它是用来访问父类的成员。而`this`关键字不需要存在继承关系也可以使用，它用于访问当前对象的成员。
- **调用构造函数不同**：使用`super`关键字可以调用父类的构造函数，而`this`关键字则用于调用本类的构造函数。

总的来说，`this`主要用于指向当前对象的成员变量和方法，以及调用当前类的其他构造函数，而`super`主要用于访问父类的成员变量和方法，以及调用父类的构造函数。
### 7. static存在的主要意义
- static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！
- static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
- 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。
### 8. static的独特之处
Java中的`static`关键字具有一些独特的特点，具体分析如下：

1. **生命周期**：静态成员随着类的加载而加载，它们的生命周期最长，会随着类的消失而消失。这意味着静态成员在程序运行期间只会被初始化一次，且在所有对象之间共享。
2. **存储位置**：静态成员变量存在于方法区中，而不是堆内存中。这与实例变量不同，实例变量是随着对象的创建而存在于堆内存中。
3. **共享性**：静态成员被所有对象所共享。例如，如果有一个`Person`类，所有`Person`对象可能有不同的名字，但它们都属于同一个国家，因此国家可以定义为静态属性，而名字则不需要。
4. **访问方式**：静态成员可以直接通过类名调用，而不需要创建类的实例。这使得静态成员在需要全局访问或不需要实例化对象的情况下非常有用。
5. **使用限制**：静态方法只能访问静态成员，因为它们不依赖于任何特定的对象实例。在静态方法中，不能使用`this`或`super`关键字，因为这些关键字引用的是当前对象或父类对象，而静态方法不与任何对象实例相关联。

总的来说，`static`关键字在Java中提供了一种创建不依赖于对象实例的成员的机制，这些成员可以在没有创建对象的情况下被访问和修改，从而提供了一种方便的方式来实现类级别的功能和数据共享。
### 9. static应用场景
在Java中，`static`关键字的应用场景主要体现在以下几个方面：

1. **成员变量**：使用`static`关键字定义的变量称为静态变量。静态变量属于类级别，而不是实例级别，这意味着无论创建多少个类的实例，静态变量都只有一个副本，并且可以在任何实例中访问。静态变量可以通过类名直接访问，不需要创建类的实例。
2. **成员方法**：使用`static`关键字定义的方法称为静态方法。静态方法可以直接通过类名调用，而不需要创建类的实例。静态方法通常用于实现工具函数或辅助函数，这些函数在应用程序中的任何地方都可以调用。
3. **代码块**：使用`static`关键字定义的代码块称为静态代码块。静态代码块在类被加载到内存时执行一次，通常用于初始化静态变量或执行仅需要执行一次的操作。
4. **内部类**：使用`static`关键字定义的嵌套类称为静态内部类。静态内部类不依赖于外部类的实例，可以直接创建实例，通常用于将一组相关的功能组合到单个实体中。

总的来说，`static`关键字的主要意义在于它提供了一种方式来创建与类相关联的成员，这些成员**可以在不创建类实例的情况下被访问和使用**。
### 10. static注意事项
1. 静态只能访问静态。
2. 非静态既可以访问非静态的，也可以访问静态的。
## 七、 流程控制语句
### 1. break ,continue ,return 的区别及作用
break, continue和return是控制程序流程的三个关键字，它们在循环结构或方法中起到不同的作用。具体分析如下：

- **break**：用于跳出当前所在的一层循环体，不再执行剩余的循环迭代。当遇到break语句时，程序会结束当前的循环，并继续执行循环之后的代码。如果存在嵌套循环，break只能终止最内层的循环。
- **continue**：用于跳过当前循环迭代中的剩余代码，直接进入下一次循环的条件判断。当遇到continue语句时，程序会停止执行当前迭代的剩余部分，跳到循环的开始处，根据循环条件判断是否执行下一次迭代。
- **return**：用于从当前方法中返回，即使return语句位于一个循环体内，它会导致方法的立即结束，不再执行方法中return之后的代码。如果方法带有返回值类型，return还可以携带返回值；否则，如果方法的返回类型是void，则return语句无需携带值。

总的来说，break是用来结束整个循环的执行，continue用来跳过当前迭代执行下一次迭代，而return则用来结束方法的执行。理解这三者的区别对于编写结构清晰、逻辑正确的程序至关重要。

### 2. 在 Java 中，如何跳出当前的多重嵌套循环
在Java中，要跳出多重嵌套循环，可以使用标签（Label）配合`break`语句。标签是一个标识符，后面紧跟一个冒号，可以将它放在循环前面，用来标识该循环。

当使用`break`语句时，可以通过在`break`后跟上标签名，来指定要跳出的是哪个循环。这样，程序就会跳出标签所标识的外层循环，而不仅仅是跳出最内层的循环。

下面是一个示例代码，展示了如何使用标签来跳出多重嵌套循环：

```java
outer: // 这是一个标签，标识外层循环
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (i * j > 10) {
            System.out.println("Breaking the loop");
            break outer; // 跳出标签为 outer 的循环
        }
    }
}
System.out.println("Loop finished");
```

在这个例子中，我们使用了标签`outer`来标识外层循环。当满足条件`i * j > 10`时，通过`break outer;`语句，程序会跳出标签为`outer`的循环，也就是外层循环。然后，程序会继续执行循环之后的代码。

使用标签配合`break`语句提供了一种灵活的方式来控制多重嵌套循环的流程，使得代码更加清晰和易于理解。